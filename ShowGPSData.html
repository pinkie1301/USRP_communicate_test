<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS 軌跡視覺化工具 (高效能版)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PapaParse for CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { margin: 0; padding: 0; font-family: 'Noto Sans TC', sans-serif; overflow: hidden; }
        #root { height: 100vh; width: 100vw; display: flex; flex-direction: column; }
        
        /* Custom Scrollbar for list */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Range Slider Styling */
        .range-slider { position: relative; width: 100%; height: 20px; touch-action: none; }
        .range-slider input {
            position: absolute; pointer-events: none; -webkit-appearance: none; z-index: 2;
            height: 10px; width: 100%; opacity: 0; cursor: pointer;
        }
        .range-slider input::-webkit-slider-thumb {
            pointer-events: all; width: 24px; height: 24px; border-radius: 50%;
            background: #3b82f6; cursor: pointer; -webkit-appearance: none;
        }
        .slider-track {
            position: absolute; top: 50%; transform: translateY(-50%);
            height: 4px; width: 100%; background: #e2e8f0; border-radius: 2px; z-index: 1;
        }
        .slider-range {
            position: absolute; top: 50%; transform: translateY(-50%);
            height: 4px; background: #3b82f6; z-index: 1;
        }
        .thumb {
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            width: 16px; height: 16px; background: #FFF; border: 2px solid #3b82f6;
            border-radius: 50%; z-index: 3; pointer-events: none; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            transition: left 0.1s; /* Slight smooth for visual only */
        }
        .thumb.left { left: 0%; }
        .thumb.right { left: 100%; }
        
        .loading-overlay {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Helper Functions ---

        function getColorByProgress(progress) {
            // Hue: 240 (Blue) -> 0 (Red)
            // Clamp progress between 0 and 1
            const p = Math.max(0, Math.min(1, progress));
            const hue = (1 - p) * 240; 
            return `hsl(${hue}, 100%, 50%)`;
        }

        function formatTime(dateObj) {
            if (!dateObj || isNaN(dateObj.getTime())) return "Invalid Time";
            return dateObj.toLocaleTimeString('zh-TW', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Custom Hook: Debounce
        function useDebounce(value, delay) {
            const [debouncedValue, setDebouncedValue] = useState(value);
            useEffect(() => {
                const handler = setTimeout(() => {
                    setDebouncedValue(value);
                }, delay);
                return () => clearTimeout(handler);
            }, [value, delay]);
            return debouncedValue;
        }

        // --- Components ---

        // Optimized Dual Handle Slider
        const DualRangeSlider = React.memo(({ min, max, onChange, disabled }) => {
            const [minVal, setMinVal] = useState(min);
            const [maxVal, setMaxVal] = useState(max);

            // Update internal state when props change significantly (e.g. new file loaded)
            useEffect(() => {
                setMinVal(min);
                setMaxVal(max);
            }, [min, max]);

            const handleMinChange = (event) => {
                const value = Math.min(Number(event.target.value), maxVal - 1);
                setMinVal(value);
                onChange(value, maxVal);
            };

            const handleMaxChange = (event) => {
                const value = Math.max(Number(event.target.value), minVal + 1);
                setMaxVal(value);
                onChange(minVal, value);
            };

            const percentMin = useMemo(() => {
                if(max === min) return 0;
                return ((minVal - min) / (max - min)) * 100;
            }, [minVal, min, max]);

            const percentMax = useMemo(() => {
                if(max === min) return 100;
                return ((maxVal - min) / (max - min)) * 100;
            }, [maxVal, min, max]);

            if (min >= max) return <div className="text-gray-400 text-sm">資料不足，無法顯示時間軸</div>;

            return (
                <div className={`range-slider mt-2 mb-4 ${disabled ? 'opacity-50 pointer-events-none' : ''}`}>
                    <input type="range" min={min} max={max} value={minVal} onChange={handleMinChange} />
                    <input type="range" min={min} max={max} value={maxVal} onChange={handleMaxChange} />
                    
                    <div className="slider-track" />
                    <div 
                        className="slider-range" 
                        style={{ left: `${percentMin}%`, width: `${percentMax - percentMin}%` }} 
                    />
                    <div className="thumb" style={{ left: `${percentMin}%` }} />
                    <div className="thumb" style={{ left: `${percentMax}%` }} />
                </div>
            );
        });

        const App = () => {
            const [rawPoints, setRawPoints] = useState([]);
            
            // Slider State (Immediate UI feedback)
            const [sliderRange, setSliderRange] = useState([0, 0]);
            
            // Map Data State (Debounced for performance)
            // We use the debounced value of the slider to trigger map filtering
            const debouncedRange = useDebounce(sliderRange, 300); // 300ms delay

            const [filteredPoints, setFilteredPoints] = useState([]);
            
            // Settings
            const [showLines, setShowLines] = useState(false);
            const [loading, setLoading] = useState(false);
            const [isRendering, setIsRendering] = useState(false);
            const [fileName, setFileName] = useState("");
            
            // Map Ref
            const mapContainerRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const layersRef = useRef({ markers: null, polyline: null });

            // Initialize Map
            useEffect(() => {
                if (!mapContainerRef.current) return;

                const map = L.map(mapContainerRef.current, {
                    preferCanvas: true // CRITICAL: Use Canvas renderer by default for whole map
                }).setView([23.97565, 120.97388], 7);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(map);

                mapInstanceRef.current = map;
                
                // Init FeatureGroup for easier management
                layersRef.current.markers = L.featureGroup().addTo(map);

                return () => {
                    map.remove();
                };
            }, []);

            // Handle File Upload
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setFileName(file.name);
                setLoading(true);

                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        processData(results.data);
                        setLoading(false);
                    },
                    error: (err) => {
                        console.error("CSV Error:", err);
                        alert("讀取 CSV 失敗");
                        setLoading(false);
                    }
                });
            };

            const processData = (data) => {
                const validPoints = data
                    .filter(row => row.lat !== null && row.lon !== null && row.time_stamp)
                    .map(row => ({
                        lat: row.lat,
                        lon: row.lon,
                        time: new Date(row.time_stamp),
                        timestamp: new Date(row.time_stamp).getTime()
                    }))
                    .sort((a, b) => a.timestamp - b.timestamp);

                if (validPoints.length === 0) {
                    alert("找不到有效的 GPS 資料");
                    return;
                }

                setRawPoints(validPoints);
                // Initialize range
                const maxIdx = validPoints.length - 1;
                setSliderRange([0, maxIdx]);
                // This will trigger the debounced effect eventually
                
                // Initial fit bounds
                if (mapInstanceRef.current) {
                    const bounds = validPoints.map(p => [p.lat, p.lon]);
                    mapInstanceRef.current.fitBounds(bounds, { padding: [50, 50] });
                }
            };

            // Slider Handler (Fast UI update)
            const handleSliderChange = useCallback((min, max) => {
                setSliderRange([min, max]);
            }, []);

            // Effect: Update Filtered Points when Debounced Range changes
            useEffect(() => {
                if (rawPoints.length === 0) return;
                
                setIsRendering(true);
                
                // Use setTimeout to allow UI to render "Rendering..." state before heavy calculation
                setTimeout(() => {
                    const [min, max] = debouncedRange;
                    const subset = rawPoints.slice(min, max + 1);
                    setFilteredPoints(subset);
                    setIsRendering(false);
                }, 10);
            }, [debouncedRange, rawPoints]);


            // Effect: Render Map Layers (Heavy Duty)
            useEffect(() => {
                const map = mapInstanceRef.current;
                if (!map || filteredPoints.length === 0) return;

                // Performance: Batch layer updates
                const markerGroup = layersRef.current.markers;
                markerGroup.clearLayers(); // Remove all old markers

                if (layersRef.current.polyline) {
                    map.removeLayer(layersRef.current.polyline);
                    layersRef.current.polyline = null;
                }

                const latlngs = [];
                const totalPoints = filteredPoints.length;
                
                // Use a local variable to batch markers before adding to group (slight perf boost)
                const newMarkers = [];

                // Optimization: If points are massive (> 10,000), consider reducing visual density if needed.
                // But Canvas renderer handles 10k-50k reasonably well.
                
                for (let i = 0; i < totalPoints; i++) {
                    const pt = filteredPoints[i];
                    latlngs.push([pt.lat, pt.lon]);

                    // Calculate Gradient
                    // Prevent division by zero if single point
                    const progress = totalPoints > 1 ? i / (totalPoints - 1) : 0;
                    const color = getColorByProgress(progress);

                    const circle = L.circleMarker([pt.lat, pt.lon], {
                        radius: 5,
                        fillColor: color,
                        color: "#ffffff",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.9,
                        renderer: L.canvas(), // Explicitly use Canvas
                        interactive: true // Keep interactive
                    });

                    // Add Popup
                    circle.bindPopup(`
                        <div class="font-sans p-1">
                            <div class="font-bold text-sm text-blue-700">時間: ${formatTime(pt.time)}</div>
                            <div class="text-xs text-gray-600 mt-1">Lat: ${pt.lat.toFixed(6)}</div>
                            <div class="text-xs text-gray-600">Lon: ${pt.lon.toFixed(6)}</div>
                            <div class="text-xs text-gray-400 mt-1">Point: ${i + 1} / ${totalPoints}</div>
                        </div>
                    `);

                    newMarkers.push(circle);
                }

                // Batch add
                newMarkers.forEach(m => markerGroup.addLayer(m));

                // Draw Polyline if enabled
                if (showLines && latlngs.length > 1) {
                    const polyline = L.polyline(latlngs, {
                        color: '#555',
                        weight: 2,
                        opacity: 0.5,
                        smoothFactor: 1.5, // Simplify line for performance
                        interactive: false // Line not clickable to save perf
                    });
                    polyline.addTo(map);
                    layersRef.current.polyline = polyline;
                }

            }, [filteredPoints, showLines]);

            // Calculate display times for UI
            const startTime = rawPoints[sliderRange[0]]?.time;
            const endTime = rawPoints[sliderRange[1]]?.time;

            return (
                <div className="flex flex-col h-full w-full relative">
                    
                    {/* Control Panel */}
                    <div className="absolute top-4 left-4 z-[1000] bg-white/95 backdrop-blur shadow-lg rounded-xl p-4 w-80 max-h-[90vh] overflow-y-auto border border-gray-200 transition-all">
                        <div className="flex items-center justify-between mb-4">
                            <h1 className="text-lg font-bold text-gray-800 flex items-center gap-2">
                                <i data-lucide="map-pin" className="w-5 h-5 text-blue-600"></i>
                                GPS 視覺化 (Pro)
                            </h1>
                            {isRendering && <span className="text-xs text-orange-500 font-bold animate-pulse">繪製中...</span>}
                        </div>

                        {/* File Upload */}
                        <div className="mb-6">
                            <label className={`flex flex-col items-center justify-center w-full h-20 border-2 border-dashed rounded-lg cursor-pointer transition-colors ${loading ? 'bg-gray-100 border-gray-300' : 'border-blue-300 bg-blue-50 hover:bg-blue-100'}`}>
                                <div className="flex flex-col items-center justify-center pt-2 pb-2">
                                    {loading ? (
                                        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-gray-500"></div>
                                    ) : (
                                        <>
                                            <i data-lucide="upload" className="w-6 h-6 text-blue-500 mb-1"></i>
                                            <p className="text-xs text-gray-500 font-medium truncate max-w-[200px]">
                                                {fileName ? fileName : "點擊上傳 CSV"}
                                            </p>
                                        </>
                                    )}
                                </div>
                                <input type="file" className="hidden" accept=".csv" onChange={handleFileUpload} disabled={loading} />
                            </label>
                        </div>

                        {rawPoints.length > 0 && (
                            <div className="space-y-5 animate-fade-in">
                                {/* Toggle Switch */}
                                <div className="flex items-center justify-between bg-gray-50 p-2 rounded-lg">
                                    <span className="text-sm font-medium text-gray-700">連線模式</span>
                                    <button 
                                        onClick={() => setShowLines(!showLines)}
                                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none ${showLines ? 'bg-blue-600' : 'bg-gray-300'}`}
                                    >
                                        <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition duration-200 ease-in-out ${showLines ? 'translate-x-6' : 'translate-x-1'}`} />
                                    </button>
                                </div>

                                {/* Stats */}
                                <div className="grid grid-cols-2 gap-2 text-center">
                                    <div className="bg-blue-50 p-2 rounded">
                                        <div className="text-xs text-gray-500">原始點數</div>
                                        <div className="font-bold text-blue-700">{rawPoints.length}</div>
                                    </div>
                                    <div className={`p-2 rounded transition-colors ${isRendering ? 'bg-orange-50' : 'bg-green-50'}`}>
                                        <div className="text-xs text-gray-500">目前顯示</div>
                                        <div className={`font-bold ${isRendering ? 'text-orange-600' : 'text-green-700'}`}>
                                            {filteredPoints.length}
                                        </div>
                                    </div>
                                </div>

                                {/* Slider */}
                                <div>
                                    <div className="flex justify-between text-xs text-gray-500 mb-1">
                                        <span>區間篩選</span>
                                    </div>
                                    
                                    <div className="flex justify-between items-end mb-1">
                                        <div className="text-xs font-mono text-blue-600 bg-blue-50 px-1 rounded">{formatTime(startTime)}</div>
                                        <div className="text-xs font-mono text-red-600 bg-red-50 px-1 rounded">{formatTime(endTime)}</div>
                                    </div>

                                    <DualRangeSlider 
                                        min={0} 
                                        max={rawPoints.length - 1} 
                                        onChange={handleSliderChange}
                                        disabled={isRendering}
                                    />
                                </div>

                                {/* Legend */}
                                <div>
                                    <div className="h-2 w-full rounded-full bg-gradient-to-r from-[hsl(240,100%,50%)] via-[hsl(120,100%,50%)] to-[hsl(0,100%,50%)]"></div>
                                    <div className="flex justify-between text-[10px] text-gray-400 mt-1">
                                        <span>Start</span>
                                        <span>End</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Map & Loading Overlay */}
                    <div className="relative flex-grow">
                        <div ref={mapContainerRef} className="h-full w-full z-0 bg-gray-100"></div>
                        
                        {/* Global Loading Overlay */}
                        {(loading || isRendering) && (
                            <div className="absolute inset-0 z-[500] loading-overlay flex flex-col items-center justify-center">
                                <div className="bg-white p-4 rounded-xl shadow-xl flex flex-col items-center animate-bounce-small">
                                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-2"></div>
                                    <span className="text-sm font-bold text-gray-700">
                                        {loading ? "解析資料中..." : "渲染地圖中..."}
                                    </span>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        
        window.addEventListener('load', () => {
            lucide.createIcons();
        });
    </script>
</body>
</html>